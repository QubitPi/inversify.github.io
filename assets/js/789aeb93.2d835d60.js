"use strict";(self.webpackChunk_inversifyjs_inversify_docs_site=self.webpackChunk_inversifyjs_inversify_docs_site||[]).push([["1480"],{8441:function(n,e,i){i.r(e),i.d(e,{frontMatter:()=>l,default:()=>y,toc:()=>u,metadata:()=>r,assets:()=>p,contentTitle:()=>h});var r=JSON.parse('{"id":"fundamentals/di-hierarchy","title":"DI Hierarchy","description":"InversifyJS is a popular library for implementing inversion of control (IoC) and dependency injection (DI) in TypeScript applications. It supports hierarchical dependency injection, which can be a powerful tool in complex applications.","source":"@site/versioned_docs/version-7.x/fundamentals/di-hierarchy.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/di-hierarchy","permalink":"/docs/fundamentals/di-hierarchy","draft":false,"unlisted":false,"tags":[],"version":"7.x","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"DI Hierarchy"},"sidebar":"tutorialSidebar","previous":{"title":"Binding","permalink":"/docs/fundamentals/binding"},"next":{"title":"Activation","permalink":"/docs/fundamentals/lifecycle/activation"}}'),a=i(3112),t=i(1131),o=i(3649),s=i(7590),c=i(7382),d=i(5143);let l={sidebar_position:2,title:"DI Hierarchy"},h="DI Hierarchy",p={},u=[{value:"Chained Resolution Mode",id:"chained-resolution-mode",level:2},{value:"Standard Resolution Mode",id:"standard-resolution-mode",level:3},{value:"Chained Resolution Mode",id:"chained-resolution-mode-1",level:3}];function f(n){let e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",...(0,t.a)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"di-hierarchy",children:"DI Hierarchy"})}),"\n",(0,a.jsx)(e.p,{children:"InversifyJS is a popular library for implementing inversion of control (IoC) and dependency injection (DI) in TypeScript applications. It supports hierarchical dependency injection, which can be a powerful tool in complex applications."}),"\n",(0,a.jsx)(e.p,{children:"With InversifyJS's hierarchical injection system, you can create a hierarchy of containers where each container can have a parent container. This allows for better organization and separation of concerns in your application."}),"\n",(0,a.jsx)(e.p,{children:"When a dependency needs to be injected, InversifyJS starts by looking in the current container for a binding. If the binding is not found, it moves up the hierarchy to the parent container and continues the search. This process continues until a binding is found or the top-level parent container is reached."}),"\n",(0,a.jsx)(e.admonition,{type:"warning",children:(0,a.jsx)(e.p,{children:"Found bindings might be discarded if their constraints are not met. For example, if a named binding is found in the child container for the requested service, that binding overrides parent bindings even if this binding is later discarded in a non-named resolution request."})}),"\n",(0,a.jsx)(e.p,{children:"By using InversifyJS's hierarchical injection system, you can easily manage complex dependencies and keep your code clean and modular. It provides a flexible and scalable solution for handling dependencies in your TypeScript applications."}),"\n",(0,a.jsx)(d.Z,{language:"ts",children:c}),"\n",(0,a.jsx)(e.h2,{id:"chained-resolution-mode",children:"Chained Resolution Mode"}),"\n",(0,a.jsxs)(e.p,{children:["InversifyJS supports two different resolution modes when working with container hierarchies: ",(0,a.jsx)(e.strong,{children:"standard resolution"})," and ",(0,a.jsx)(e.strong,{children:"chained resolution"}),"."]}),"\n",(0,a.jsx)(e.h3,{id:"standard-resolution-mode",children:"Standard Resolution Mode"}),"\n",(0,a.jsxs)(e.p,{children:["In standard resolution mode (the default behavior), InversifyJS follows a ",(0,a.jsx)(e.strong,{children:"first-found"})," approach:"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"First, it searches for bindings in the current container"}),"\n",(0,a.jsx)(e.li,{children:"If bindings are found in the current container, those bindings are used exclusively"}),"\n",(0,a.jsx)(e.li,{children:"If no bindings are found in the current container, it moves up to the parent container"}),"\n",(0,a.jsx)(e.li,{children:"This process continues until bindings are found or the top-level container is reached"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"This means that if a child container has any bindings for a service, the parent container's bindings for that same service will be ignored entirely:"}),"\n",(0,a.jsx)(d.Z,{language:"ts",children:s}),"\n",(0,a.jsx)(e.h3,{id:"chained-resolution-mode-1",children:"Chained Resolution Mode"}),"\n",(0,a.jsxs)(e.p,{children:["Chained resolution mode allows you to collect bindings from ",(0,a.jsx)(e.strong,{children:"all levels"})," of the container hierarchy. When using ",(0,a.jsx)(e.code,{children:"getAll()"})," or ",(0,a.jsx)(e.code,{children:"getAllAsync()"})," with the ",(0,a.jsx)(e.code,{children:"chained: true"})," option:"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Bindings are collected from the current container"}),"\n",(0,a.jsx)(e.li,{children:"Then bindings are collected from the parent container"}),"\n",(0,a.jsx)(e.li,{children:"This continues recursively up the entire hierarchy"}),"\n",(0,a.jsx)(e.li,{children:"All collected bindings are combined and returned"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"This is particularly useful when you want to aggregate services from different layers of your application (e.g., core services from a parent container and feature-specific services from child containers)."}),"\n",(0,a.jsx)(d.Z,{language:"ts",children:o})]})}function y(n={}){let{wrapper:e}={...(0,t.a)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(f,{...n})}):f(n)}},3649:function(n){n.exports="const parentContainer: Container = new Container();\n\nconst container: Container = new Container({\n  parent: parentContainer,\n});\n\nparentContainer.bind<Weapon>('Weapon').to(Katana);\ncontainer.bind<Weapon>('Weapon').to(Shuriken);\n\n// returns Weapon[] with both Katana and Shuriken instances\nconst weapons: Weapon[] = container.getAll<Weapon>('Weapon', { chained: true });"},7590:function(n){n.exports="const parentContainer: Container = new Container();\n\nconst container: Container = new Container({\n  parent: parentContainer,\n});\n\nparentContainer.bind<Weapon>('Weapon').to(Katana);\ncontainer.bind<Weapon>('Weapon').to(Shuriken);\n\n// returns Weapon[] with only a Shuriken instance\nconst weapons: Weapon[] = container.getAll<Weapon>('Weapon', {\n  chained: false,\n});"},7382:function(n){n.exports="class Katana {}\n\nconst parentContainer: Container = new Container();\nparentContainer.bind(weaponIdentifier).to(Katana);\n\nconst childContainer: Container = new Container({ parent: parentContainer });\n\nconst katana: Katana = childContainer.get(weaponIdentifier);"}}]);