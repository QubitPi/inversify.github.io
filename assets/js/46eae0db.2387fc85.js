"use strict";(self.webpackChunk_inversifyjs_inversify_docs_site=self.webpackChunk_inversifyjs_inversify_docs_site||[]).push([["1322"],{7799:function(n,e,t){t.r(e),t.d(e,{default:()=>f,frontMatter:()=>p,metadata:()=>i,assets:()=>x,toc:()=>b,contentTitle:()=>m});var i=JSON.parse('{"id":"guides/migrating-from-v6","title":"Migrating from v6","description":"InversifyJS v7 introduces a few breaking changes. This guide will help you migrate your existing InversifyJS v6 code to v7.","source":"@site/docs/guides/migrating-from-v6.mdx","sourceDirName":"guides","slug":"/guides/migrating-from-v6","permalink":"/docs/next/guides/migrating-from-v6","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Migrating from v6"},"sidebar":"tutorialSidebar","previous":{"title":"Using bundlers","permalink":"/docs/next/faq/using-bundlers"}}'),a=t("8771"),o=t("6986"),s=t("8530"),r=t("6789"),d=t("8189"),c=t("9488"),l=t("7998"),h=t("7382"),u=t("116"),g=t("3965");let p={sidebar_position:1,title:"Migrating from v6"},m="Migrating from v6",x={},b=[{value:"Container API",id:"container-api",level:2},{value:"Autobinding",id:"autobinding",level:3},{value:"Custom metadata and middlewares",id:"custom-metadata-and-middlewares",level:3},{value:"isBound like methods",id:"isbound-like-methods",level:3},{value:"get like methods",id:"get-like-methods",level:3},{value:"load and unload methods",id:"load-and-unload-methods",level:3},{value:"unbind and unbindAll methods",id:"unbind-and-unbindall-methods",level:3},{value:"Parent and child containers",id:"parent-and-child-containers",level:3},{value:"ContainerModule API",id:"containermodule-api",level:2},{value:"BindingFluentSyntax API",id:"bindingfluentsyntax-api",level:2},{value:"Use of ResolutionContext instead of interfaces.Context",id:"use-of-resolutioncontext-instead-of-interfacescontext",level:3},{value:"Use of BindingConstraints instead of interfaces.Request",id:"use-of-bindingconstraints-instead-of-interfacesrequest",level:3}];function j(n){let e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",...(0,o.a)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"migrating-from-v6",children:"Migrating from v6"})}),"\n",(0,a.jsx)(e.p,{children:"InversifyJS v7 introduces a few breaking changes. This guide will help you migrate your existing InversifyJS v6 code to v7."}),"\n",(0,a.jsx)(e.h2,{id:"container-api",children:"Container API"}),"\n",(0,a.jsx)(e.h3,{id:"autobinding",children:"Autobinding"}),"\n",(0,a.jsxs)(e.p,{children:["In v6, you could enable autobinding by passing the ",(0,a.jsx)(e.code,{children:"autoBindInjectable"})," option to the container constructor. In v7, this option has been renamed to ",(0,a.jsx)(e.code,{children:"autobind"})," which can be passed either as part of ",(0,a.jsx)(e.code,{children:"Container"})," constructor options or ",(0,a.jsx)(e.code,{children:"Container.get"})," options."]}),"\n",(0,a.jsxs)(e.p,{children:["In v6, ",(0,a.jsx)(e.code,{children:"container.resolve"})," would automatically bind the resolved service to the container. In v7, this behavior has been removed. You can enable this behavior by passing the ",(0,a.jsx)(e.code,{children:"autobind"})," option."]}),"\n",(0,a.jsx)(g.Z,{language:"ts",children:u}),"\n",(0,a.jsx)(e.h3,{id:"custom-metadata-and-middlewares",children:"Custom metadata and middlewares"}),"\n",(0,a.jsx)(e.p,{children:"This is the only feature that has been removed in v7 with no direct replacement. The API was not super useful, not widely used and was one of the main reasons for the complexity of the library. We might bring it back in the future with a better API."}),"\n",(0,a.jsx)(e.h3,{id:"isbound-like-methods",children:"isBound like methods"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:"Container.isBoundNamed"}),", ",(0,a.jsx)(e.code,{children:"Container.isBoundTagged"})," behavior can be achieved relying on ",(0,a.jsx)(e.code,{children:"Container.isBound"}),". Optional ",(0,a.jsx)(e.code,{children:"isBoundOptions"})," can be passed to find named and tagged bindings."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:"Container.isCurrentBound"})," has been updated with the same optional ",(0,a.jsx)(e.code,{children:"isBoundOptions"})," parameter in order to find named and tagged bindings."]}),"\n",(0,a.jsxs)(e.p,{children:["Refer to the API ",(0,a.jsx)(e.a,{href:"../../api/container#isbound",children:"isBound"})," and ",(0,a.jsx)(e.a,{href:"../../api/container#iscurrentbound",children:"isCurrentBound"})," documentation for more information."]}),"\n",(0,a.jsx)(e.h3,{id:"get-like-methods",children:"get like methods"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:"Container"})," has been updated with no ",(0,a.jsx)(e.code,{children:"getNamed"}),", ",(0,a.jsx)(e.code,{children:"getTagged"}),", ",(0,a.jsx)(e.code,{children:"tryGet"}),", ",(0,a.jsx)(e.code,{children:"tryGetNamed"})," and ",(0,a.jsx)(e.code,{children:"tryGetTagged"})," methods in favor of ",(0,a.jsx)(e.code,{children:"Container.get"})," with ",(0,a.jsx)(e.code,{children:"OptionalGetOptions"})," options."]}),"\n",(0,a.jsxs)(e.p,{children:["The same applies to ",(0,a.jsx)(e.code,{children:"Container.getAll"}),", ",(0,a.jsx)(e.code,{children:"Container.getAllAsync"})," and ",(0,a.jsx)(e.code,{children:"Container.getAsync"}),", they all now receive a ",(0,a.jsx)(e.code,{children:"GetOptions"})," object which can be used to pass expected name or tags."]}),"\n",(0,a.jsx)(g.Z,{language:"ts",children:c}),"\n",(0,a.jsxs)(e.p,{children:["Last but not least, ",(0,a.jsx)(e.code,{children:"Container.getAll"})," and ",(0,a.jsx)(e.code,{children:"Container.getAllAsync"})," methods now enforce service bindings to respect binding constraints. Given the following example:"]}),"\n",(0,a.jsx)(g.Z,{language:"ts",children:d}),"\n",(0,a.jsxs)(e.p,{children:["In v6, ",(0,a.jsx)(e.code,{children:"container.getAll"})," would return an array with all bindings that match the service identifier. In v7, ",(0,a.jsx)(e.code,{children:"container.getAll"})," will return an array with all bindings that match the service identifier and the binding constraints, so the shuriken binding will not be used and, therefore, an array with a single katana will be provided as the resolved value for the service."]}),"\n",(0,a.jsx)(e.h3,{id:"load-and-unload-methods",children:"load and unload methods"}),"\n",(0,a.jsx)(e.p,{children:"This methods are now asynncronous and therefore return a promise."}),"\n",(0,a.jsx)(g.Z,{language:"ts",children:l}),"\n",(0,a.jsx)(e.h3,{id:"unbind-and-unbindall-methods",children:"unbind and unbindAll methods"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:"Container.unbind"})," and ",(0,a.jsx)(e.code,{children:"Container.unbindAll"})," methods are now asynchronous and return a promise. ",(0,a.jsx)(e.code,{children:"Container.unbindAsync"})," and ",(0,a.jsx)(e.code,{children:"Container.unbindAllAsync"})," methods have been removed."]}),"\n",(0,a.jsx)(e.h3,{id:"parent-and-child-containers",children:"Parent and child containers"}),"\n",(0,a.jsxs)(e.p,{children:["In v6, you could create a child container by calling the ",(0,a.jsx)(e.code,{children:"createChild"})," method on a parent container. In v7, this method has been removed. Instead, you can create a child container by passing the parent container to the constructor of the child container."]}),"\n",(0,a.jsx)(g.Z,{language:"ts",children:h}),"\n",(0,a.jsx)(e.h2,{id:"containermodule-api",children:"ContainerModule API"}),"\n",(0,a.jsx)(e.p,{children:"Container module load options have been updated to be an object."}),"\n",(0,a.jsx)(g.Z,{language:"ts",children:l}),"\n",(0,a.jsx)(e.h2,{id:"bindingfluentsyntax-api",children:"BindingFluentSyntax API"}),"\n",(0,a.jsx)(e.h3,{id:"use-of-resolutioncontext-instead-of-interfacescontext",children:"Use of ResolutionContext instead of interfaces.Context"}),"\n",(0,a.jsxs)(e.p,{children:["In v6, the ",(0,a.jsx)(e.code,{children:"Context"})," class was used to pass contextual information. Too many internal data structures were exposed to the user. In v7, the ",(0,a.jsx)(e.code,{children:"ResolutionContext"})," class is used to pass contextual information. This class is more focused on the user's needs and hides internal data structures to keep the API simple and maintainable."]}),"\n",(0,a.jsx)(g.Z,{language:"ts",children:s}),"\n",(0,a.jsx)(e.h3,{id:"use-of-bindingconstraints-instead-of-interfacesrequest",children:"Use of BindingConstraints instead of interfaces.Request"}),"\n",(0,a.jsxs)(e.p,{children:["In v6, binding constraints received a ",(0,a.jsx)(e.code,{children:"Request"})," object. In v7, binding constraints receive a ",(0,a.jsx)(e.code,{children:"BindingConstraints"})," object. This object is more focused on the user's needs and hides internal data structures to keep the API simple and maintainable."]}),"\n",(0,a.jsx)(g.Z,{language:"ts",children:r})]})}function f(n={}){let{wrapper:e}={...(0,o.a)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(j,{...n})}):j(n)}},8530:function(n){n.exports="@injectable()\nclass Katana {\n  public use(): string {\n    return 'hit!';\n  }\n}\n\ncontainer\n  .bind<Katana>('Katana')\n  .to(Katana)\n  .onActivation((_context: ResolutionContext, katana: Katana) => {\n    const handler: ProxyHandler<() => string> = {\n      apply: function (\n        target: () => string,\n        thisArgument: unknown,\n        argumentsList: [],\n      ) {\n        console.log(`Starting: ${new Date().getTime().toString()}`);\n        const result: string = target.apply(thisArgument, argumentsList);\n        console.log(`Finished: ${new Date().getTime().toString()}`);\n        return result;\n      },\n    };\n\n    katana.use = new Proxy(katana.use.bind(katana), handler);\n\n    return katana;\n  });"},6789:function(n){n.exports="const ninjaId: symbol = Symbol.for('Ninja');\nconst weaponId: symbol = Symbol.for('Weapon');\n\n@injectable()\nclass Ninja {\n  constructor(\n    @inject(weaponId)\n    @named('shuriken')\n    public readonly weapon: Weapon,\n  ) {}\n}\n\ncontainer.bind<Ninja>(ninjaId).to(Ninja);\n\nconst whenTargetNamedConstraint: (\n  name: string,\n) => (bindingconstraints: BindingConstraints) => boolean =\n  (name: string) =>\n  (bindingconstraints: BindingConstraints): boolean =>\n    bindingconstraints.name === name;\n\ncontainer\n  .bind<Weapon>(weaponId)\n  .to(Katana)\n  .when(whenTargetNamedConstraint('katana'));\n\ncontainer\n  .bind<Weapon>(weaponId)\n  .to(Shuriken)\n  .when(whenTargetNamedConstraint('shuriken'));\n\nconst ninja: Ninja = container.get(ninjaId);\n\n// Returns 5\nconst ninjaDamage: number = ninja.weapon.damage;"},8189:function(n){n.exports="const container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana);\ncontainer.bind<Weapon>('Weapon').to(Shuriken).whenNamed('ranged');\n\nconst weapons: Weapon[] = container.getAll<Weapon>('Weapon');"},9488:function(n){n.exports="const container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana).whenNamed('Katana');\n\nconst katana: Weapon = container.get<Weapon>('Weapon', { name: 'Katana' });"},7998:function(n){n.exports="const warriorsModule: ContainerModule = new ContainerModule(\n  (options: ContainerModuleLoadOptions) => {\n    options.bind<Ninja>('Ninja').to(Ninja);\n  },\n);\n\nconst weaponsModule: ContainerModule = new ContainerModule(\n  (options: ContainerModuleLoadOptions) => {\n    options.bind<Katana>('Weapon').to(Katana).whenNamed('Melee');\n    options.bind<Shuriken>('Weapon').to(Shuriken).whenNamed('Ranged');\n  },\n);\n\nawait container.load(warriorsModule, weaponsModule);\n\nconst ninja: Ninja = container.get('Ninja');"},7382:function(n){n.exports="class Katana {}\n\nconst parentContainer: Container = new Container();\nparentContainer.bind(weaponIdentifier).to(Katana);\n\nconst childContainer: Container = new Container({ parent: parentContainer });\n\nconst katana: Katana = childContainer.get(weaponIdentifier);"},116:function(n){n.exports="export class Katana {\n  public readonly damage: number = 10;\n}\n\n@injectable()\nexport class Samurai {\n  public readonly katana: Katana;\n\n  constructor(katana: Katana) {\n    this.katana = katana;\n  }\n}\n\nconst container: Container = new Container();\n\nconst samurai: Samurai = container.get(Samurai, { autobind: true });"}}]);