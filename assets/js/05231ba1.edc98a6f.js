"use strict";(self.webpackChunk_inversifyjs_inversify_docs_site=self.webpackChunk_inversifyjs_inversify_docs_site||[]).push([["3368"],{2412:function(n,e,i){i.r(e),i.d(e,{default:()=>h,frontMatter:()=>s,metadata:()=>a,assets:()=>d,toc:()=>l,contentTitle:()=>c});var a=JSON.parse('{"id":"fundamentals/di-hierarchy","title":"DI Hierarchy","description":"InversifyJS is a popular library for implementing inversion of control (IoC) and dependency injection (DI) in TypeScript applications. It supports hierarchical dependency injection, which can be a powerful tool in complex applications.","source":"@site/versioned_docs/version-6.x/fundamentals/di-hierarchy.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/di-hierarchy","permalink":"/docs/6.x/fundamentals/di-hierarchy","draft":false,"unlisted":false,"tags":[],"version":"6.x","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"DI Hierarchy"},"sidebar":"tutorialSidebar","previous":{"title":"Binding","permalink":"/docs/6.x/fundamentals/binding"},"next":{"title":"Activation","permalink":"/docs/6.x/fundamentals/lifecycle/activation"}}'),r=i("3112"),t=i("9045"),o=i("7976");let s={sidebar_position:2,title:"DI Hierarchy"},c="DI Hierarchy",d={},l=[];function p(n){let e={admonition:"admonition",h1:"h1",header:"header",p:"p",...(0,t.a)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"di-hierarchy",children:"DI Hierarchy"})}),"\n",(0,r.jsx)(e.p,{children:"InversifyJS is a popular library for implementing inversion of control (IoC) and dependency injection (DI) in TypeScript applications. It supports hierarchical dependency injection, which can be a powerful tool in complex applications."}),"\n",(0,r.jsx)(e.p,{children:"With InversifyJS's hierarchical injection system, you can create a hierarchy of containers where each container can have a parent container. This allows for better organization and separation of concerns in your application."}),"\n",(0,r.jsx)(e.p,{children:"When a dependency needs to be injected, InversifyJS starts by looking in the current container for a binding. If the binding is not found, it moves up the hierarchy to the parent container and continues the search. This process continues until a binding is found or the top-level parent container is reached."}),"\n",(0,r.jsx)(e.admonition,{type:"warning",children:(0,r.jsx)(e.p,{children:"Found bindings might be discarded if their constraints are not met. For example, if a named binding is found in the child container for the requested service, that binding overrides parent bindings even if this binding is later discarded in a non-named resolution request."})}),"\n",(0,r.jsx)(e.p,{children:"By using InversifyJS's hierarchical injection system, you can easily manage complex dependencies and keep your code clean and modular. It provides a flexible and scalable solution for handling dependencies in your TypeScript applications."}),"\n",(0,r.jsx)(o.Z,{language:"ts",children:"class Katana {}\n\nconst parentContainer: Container = new Container();\nparentContainer.bind(weaponIdentifier).to(Katana);\n\nconst childContainer: Container = parentContainer.createChild();\n\nconst katana: Katana = childContainer.get(weaponIdentifier);"})]})}function h(n={}){let{wrapper:e}={...(0,t.a)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(p,{...n})}):p(n)}}}]);