"use strict";(self.webpackChunk_inversifyjs_inversify_docs_site=self.webpackChunk_inversifyjs_inversify_docs_site||[]).push([["5305"],{3872:function(n,e,i){i.r(e),i.d(e,{default:()=>u,frontMatter:()=>c,metadata:()=>a,assets:()=>l,toc:()=>p,contentTitle:()=>d});var a=JSON.parse('{"id":"fundamentals/di-hierarchy","title":"DI Hierarchy","description":"InversifyJS is a popular library for implementing inversion of control (IoC) and dependency injection (DI) in TypeScript applications. It supports hierarchical dependency injection, which can be a powerful tool in complex applications.","source":"@site/docs/fundamentals/di-hierarchy.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/di-hierarchy","permalink":"/docs/next/fundamentals/di-hierarchy","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"DI Hierarchy"},"sidebar":"tutorialSidebar","previous":{"title":"Binding","permalink":"/docs/next/fundamentals/binding"},"next":{"title":"Activation","permalink":"/docs/next/fundamentals/lifecycle/activation"}}'),t=i("3112"),r=i("7334"),o=i("7382"),s=i("4542");let c={sidebar_position:2,title:"DI Hierarchy"},d="DI Hierarchy",l={},p=[];function h(n){let e={admonition:"admonition",h1:"h1",header:"header",p:"p",...(0,r.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"di-hierarchy",children:"DI Hierarchy"})}),"\n",(0,t.jsx)(e.p,{children:"InversifyJS is a popular library for implementing inversion of control (IoC) and dependency injection (DI) in TypeScript applications. It supports hierarchical dependency injection, which can be a powerful tool in complex applications."}),"\n",(0,t.jsx)(e.p,{children:"With InversifyJS's hierarchical injection system, you can create a hierarchy of containers where each container can have a parent container. This allows for better organization and separation of concerns in your application."}),"\n",(0,t.jsx)(e.p,{children:"When a dependency needs to be injected, InversifyJS starts by looking in the current container for a binding. If the binding is not found, it moves up the hierarchy to the parent container and continues the search. This process continues until a binding is found or the top-level parent container is reached."}),"\n",(0,t.jsx)(e.admonition,{type:"warning",children:(0,t.jsx)(e.p,{children:"Found bindings might be discarded if their constraints are not met. For example, if a named binding is found in the child container for the requested service, that binding overrides parent bindings even if this binding is later discarded in a non-named resolution request."})}),"\n",(0,t.jsx)(e.p,{children:"By using InversifyJS's hierarchical injection system, you can easily manage complex dependencies and keep your code clean and modular. It provides a flexible and scalable solution for handling dependencies in your TypeScript applications."}),"\n",(0,t.jsx)(s.Z,{language:"ts",children:o})]})}function u(n={}){let{wrapper:e}={...(0,r.a)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(h,{...n})}):h(n)}},7382:function(n){n.exports="class Katana {}\n\nconst parentContainer: Container = new Container();\nparentContainer.bind(weaponIdentifier).to(Katana);\n\nconst childContainer: Container = new Container({ parent: parentContainer });\n\nconst katana: Katana = childContainer.get(weaponIdentifier);"}}]);